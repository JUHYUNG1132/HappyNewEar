***개선사항
실내 사용의 부정확성 => ODAS.cfg 파일 내의 매개변수값을 조정함으로써 최적화 가능
위치 정보 표시의 한계 => 마이크 간의 간격을 넓히면 소리의 도달시간의 차이를 통한 위치의 측정이 가능함 (현재는 6.5cm)

***Q&A
1. 쓰레딩을 통해 함수를 실행하는 이유는??
=>데이터의 입력과 처리가 동시에 이루어져야 하는데 기존의 동기식 실행으로는 이러한 기능의 구현이 불가능함

2. ODAS에서 어떤 방식으로 작동하는지?
=>The ManyEars open framework 논문에 이론이 소개되어 있음, 마이크로 소리가 들어오면 FFT(푸리에 변환)를 이용해 변환한 뒤 딜레이를 통해 구면 상에 위치를 마킹함. 또한, 의미있는 스펙트럼을 GSS(geometric source sepration)이라는 기술을 통해 분리한 후, IFFT(역 푸리에 변환)으로 소리를 출력함
로봇과 같은 임베디드 디바이스를 위해 설계되어 (FFT가 가장 복잡한 연산일 정도로) 낮은 컴퓨팅 파워와 전력을 요구한다는 장점이 있음.

3. 텐서플로우 라이트가 무엇인지?
=> 텐서플로우는 머신러닝 모델의 학습과 재학습, 실행과 같이 포괄적인 기능을 제공하고 높은 컴퓨팅 파워를 요구하는 라이브러리(API)인데, 텐서플로우 라이트(TFLite)는 모델을 실행하는데 필요한 런타임만을 제공하는 라이브러리로, 기존 모델과의 호환성은 낮지만 빠르고 저사양 환경에서 실행가능하다는 장점이 있다.

4. 사용한 모델의 세부적인 사양?
=> YouTube에서 뽑아낸 2084320(2백만개)의 소리 데이터로 학습된 텐서플로 yamnet 모델의 텐서플로우 라이트용으로 변환된 버전. 내부적으로는 Relu6 activation function(신경망 활성화 함수)과 Mobilenet_v1이라는 분리형 합성곱 연산 아키텍처를 사용한다. 
입력 데이터는 0.98초 길이의 16KHz 1채널의, 진폭 [-1,1] 크기의 wav 데이터로, 내부적으로 STFT(Short-Time Fourier Transform)을 이용해 스펙트로그램(윈도우)로 변환된다.
결과값은 521가지 결과값에 대한 점수를 매긴 2차원 배열이다.

5. 언어로 파이썬만을 사용한 이유?
=>본래 전체적인 틀은 파이썬을 사용하고, 속도가 중요한 음원 위치 파악이나 분류하는 부분은 C언어를 사용하려 하였다. 그러나 ODAS와 텐서플로를 사용해 위치 파악과 분류를 함으로써 파이썬만을 이용해 기본적인 틀을 구성하게 되었다.

6. 외부 프로젝트를 사용한 부분이 많은데 그 이유는?
=> 소리 위치 인식과 분류의 경우 모두 높은 수준의 기술을 요구하기에 현재 우리 팀의 기술력으로는 개발에 무리가 있었다. 이미 개발되어 완성도 있는 프로젝트들을 수정, 결과값들을  시각장애인을 위한 디바이스를 만들었다는 것에 의미가 있다고 생각함.

7. 비오는 날과 같이 외부 소음이 많은 경우에는 위치 확인에 문제가 있지 않을지?
=> ODAS에 SNE(Stationary Noise Estimation). 즉, 배경 노이즈 제거가 들어있어 빗소리, 선풍기 소리와 같은 지속적인 소리는 제거된다. 또한, 위치를 표시할 소리의 임계값이 있어 빗소리와 같은 작은 소리는 인식되지 않는다. (근데 소리 분류는 잘 안될수도??)

8. 여기서 사용되는 빔포밍 기술이란 정확히 무엇?
=>빔포밍(Beamforming)은 일정한 배열을 이루고 있는 송/수신기를 이용해서 무선 신호를 보내거나 받아들일 때 방향성을 부여하기 위한 신호처리 기술이다. 여기서는 각 마이크에 도착하는 소리들의 위상차를 이용해 특정 방향에서만 들리는 소리만을 걸러내는 역할을 하게 된다.

소프트웨어 변경점

img폴더 안 이미지들 이름 한글화
yamnet_class_map.csv 파일 한글화
ODAS.cfg파일 수정(sss 부분의 fs 16000 =>32000으로 변경)

main.py 수정 
=> 	pygame 사용
	화면이 늦게뜨던 딜레이 수정(noise 함수 구조 수정, 쓰레드로 실행)
	데이터 길이 버그 수정(인식률 개선)
	한글화

Classification.py 수정
=>	classifier() 함수에 data = np.delete(data,1) 추가됨

matplotlib 쓰는 파일 = main1.py(**만약에 쓰게되면 배경화면이랑 진동은 못씀;;)

pygame 쓰는 파일 = main.py
